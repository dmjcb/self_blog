---
title: "c/c++ 工厂模式"
date: 2024-10-08
categories: [c_c++]
tags: [c_c++]
excerpt: "工厂模式"
---

工厂模式是一种创建对象的设计模式, 旨在将对象创建与使用分离

## 简单工厂

创建对象逻辑集中在一个工厂类中

```c++
#include <iostream>
#include <unordered_map>
#include <functional>
#include <memory>

class Product {
public:
    virtual ~Product() = default;
    virtual void do_use() = 0;
};

class ConcreteProductA : public Product {
public:
    ConcreteProductA() {
        std::cout << "ConcreteProductA" << std::endl;
    };

    void do_use() override {
        std::cout << "ConcreteProductA do_use" << std::endl;
    }
};

class ConcreteProductB : public Product {
public:
    ConcreteProductB() {
        std::cout << "ConcreteProductB" << std::endl;
    };

    void do_use() override {
        std::cout << "ConcreteProductB do_use" << std::endl;
    }
};

class SimpleFactory {
public:
    static std::shared_ptr<Product> create_product(const char type) {
        std::unordered_map<char, std::function<std::shared_ptr<Product>()> > products = {
            {
                'A', []() -> std::shared_ptr<Product> {
                    return std::make_shared<ConcreteProductA>();
                }
            },
            {   'B', []() -> std::shared_ptr<Product> {
                    return std::make_shared<ConcreteProductB>();
                }
            },
        };
        return products[type]();
    }
};

int main() {
    std::shared_ptr<Product> product_a = SimpleFactory::create_product('A');
    product_a->do_use();

    std::shared_ptr<Product> product_b = SimpleFactory::create_product('B');
    product_b->do_use();
    return 0;
}
```

运行结果

```sh
ConcreteProductA
ConcreteProductA do_use
ConcreteProductB
ConcreteProductB do_use
```

## 工厂方法

定义一个创建对象接口, 让子类决定实例化哪个类

```c++
class Product {
public:
    virtual ~Product() = default;
    virtual void do_use() = 0;
};

class CreatorInterface {
public:
    virtual Product* do_factory_method() = 0;
};

class ConcreteCreatorA : public CreatorInterface {
public:
    Product* do_factory_method() override {
        return new ConcreteProductA();
    }
};

class ConcreteCreatorB : public CreatorInterface {
public:
    Product* do_factory_method() override {
        return new ConcreteProductB();
    }
};
```

## 抽象工厂

提供一个创建一系列相关或相互依赖对象接口

```c++
class Product {
public:
    virtual ~Product() = default;
    virtual void do_use() = 0;
};

class ConcreteProductA : public Product {
public:
    ConcreteProductA() {
        std::cout << "ConcreteProductA" << std::endl;
    };

    void do_use() override {
        std::cout << "ConcreteProductA do_use" << std::endl;
    }
};

class ConcreteProductB : public Product {
public:
    ConcreteProductB() {
        std::cout << "ConcreteProductB" << std::endl;
    };

    void do_use() override {
        std::cout << "ConcreteProductB do_use" << std::endl;
     }
};

class AbstractFactory {
public:
    virtual ~AbstractFactory() = default;
    virtual Product* do_create_product_a() = 0;
    virtual Product* do_create_product_b() = 0;
};

class ConcreteFactory1 : public AbstractFactory {
public:
    static Product* do_create_product_a() override {
        return new ConcreteProductA();
    }

    static Product* do_create_product_b() override {
        return new ConcreteProductB();
    }
};

class ConcreteFactory2 : public AbstractFactory {
public:
    static Product* do_create_product_a() override {
        return new ConcreteProductB();
    }

    static Product* do_create_product_b() override {
        return new ConcreteProductA();
    }
};
```

这些模式区别在于简单工厂集中管理, 工厂方法提供灵活性, 而抽象工厂则处理多个产品族

## 模板工厂

通过模板参数 Factory 类可以生成任意类型对象, 而无需修改工厂类代码, 当需要添加新产品类型时, 只需要定义新产品类,并传入到 Factory 类中即可

此模式扩展性较好, 添加新产品不会影响现有代码结构

```c++
#include <iostream>
#include <memory>

class Product {
public:
    virtual void do_use() const = 0;
    virtual ~Product() = default;
};

class ProductA : public Product {
public:
    void do_use() const override {
        std::cout << "product_a created!" << std::endl;
    }
};

class ProductB : public Product {
public:
    void do_use() const override {
        std::cout << "product_b created!" << std::endl;
    }
};

template<typename T>
class Factory {
public:
    static std::shared_ptr<Product> create() {
        return std::make_shared<T>();
    }
};

int main() {
    std::shared_ptr<Product> product_a = Factory<ProductA>::create();
    product_a->do_use();

    std::shared_ptr<Product> product_b = Factory<ProductB>::create();
    product_b->do_use();
    return 0;
}
```

运行结果

```sh
product_a created!
product_b created!
```
