---
title: "c/c++ 工厂模式"
date: 2024-10-08
categories: [c_c++]
tags: [c_c++]
excerpt: "工厂模式"
---

工厂模式是一种创建对象的设计模式, 其核心思想是将对象的创建与使用分离, 从而提高代码的灵活性和可维护性

工厂模式主要有以下几种形式: 简单工厂、工厂方法、抽象工厂、模板工厂

## 简单工厂模式

将对象创建逻辑集中在一个工厂类中

扩展性较差, 增加新产品需要修改工厂类

```c++
#include <iostream>
#include <unordered_map>
#include <functional>
#include <memory>

class Product {
public:
    virtual ~Product() = default;
    virtual void do_use() = 0;
};

class ConcreteProductA : public Product {
public:
    ConcreteProductA() { std::cout << "ConcreteProductA created" << std::endl; }
    void do_use() override { std::cout << "ConcreteProductA do_use" << std::endl; }
};

class ConcreteProductB : public Product {
public:
    ConcreteProductB() { std::cout << "ConcreteProductB created" << std::endl; }
    void do_use() override { std::cout << "ConcreteProductB do_use" << std::endl; }
};

class SimpleFactory {
public:
    static std::shared_ptr<Product> create_product(char type) {
        std::unordered_map<char, std::function<std::shared_ptr<Product>()>> products = {
            {'A', [](){ return std::make_shared<ConcreteProductA>(); }},
            {'B', [](){ return std::make_shared<ConcreteProductB>(); }}
        };
        return products[type]();
    }
};

int main() {
    auto product_a = SimpleFactory::create_product('A');
    product_a->do_use();

    auto product_b = SimpleFactory::create_product('B');
    product_b->do_use();

    return 0;
}

```

运行结果

```sh
ConcreteProductA created
ConcreteProductA do_use
ConcreteProductB created
ConcreteProductB do_use
```

## 工厂方法模式

定义一个创建对象的接口, 由子类决定实例化哪个具体类

扩展性比简单工厂好, 每增加新产品只需增加新子类

```c++
class Product {
public:
    virtual ~Product() = default;
    virtual void do_use() = 0;
};

class ConcreteProductA : public Product {
public:
    void do_use() override { std::cout << "ConcreteProductA do_use" << std::endl; }
};

class ConcreteProductB : public Product {
public:
    void do_use() override { std::cout << "ConcreteProductB do_use" << std::endl; }
};

// 工厂接口
class CreatorInterface {
public:
    virtual ~CreatorInterface() = default;
    virtual Product* factory_method() = 0;
};

// 具体工厂
class ConcreteCreatorA : public CreatorInterface {
public:
    Product* factory_method() override { return new ConcreteProductA(); }
};

class ConcreteCreatorB : public CreatorInterface {
public:
    Product* factory_method() override { return new ConcreteProductB(); }
};
```

```c++
CreatorInterface* creator = new ConcreteCreatorA();
Product* product = creator->factory_method();
product->do_use();
delete product;
delete creator;
```

## 抽象工厂

提供一个创建一系列相关或相互依赖对象的接口

适合多个产品族, 保证同一工厂创建的产品互相兼容

```c++
class AbstractFactory {
public:
    virtual ~AbstractFactory() = default;
    virtual Product* create_product_a() = 0;
    virtual Product* create_product_b() = 0;
};

// 具体工厂1
class ConcreteFactory1 : public AbstractFactory {
public:
    Product* create_product_a() override { return new ConcreteProductA(); }
    Product* create_product_b() override { return new ConcreteProductB(); }
};

// 具体工厂2
class ConcreteFactory2 : public AbstractFactory {
public:
    Product* create_product_a() override { return new ConcreteProductB(); }
    Product* create_product_b() override { return new ConcreteProductA(); }
};

```

```c++
AbstractFactory* factory = new ConcreteFactory1();
Product* pa = factory->create_product_a();
Product* pb = factory->create_product_b();
pa->do_use();
pb->do_use();
delete pa;
delete pb;
delete factory;
```

## 模板工厂

使用模板参数生成任意类型对象, 无需修改工厂类

扩展性好, 添加新产品无需修改现有代码

```c++
#include <iostream>
#include <memory>

class Product {
public:
    virtual void do_use() const = 0;
    virtual ~Product() = default;
};

class ProductA : public Product {
public:
    void do_use() const override { std::cout << "ProductA created!" << std::endl; }
};

class ProductB : public Product {
public:
    void do_use() const override { std::cout << "ProductB created!" << std::endl; }
};

template<typename T>
class Factory {
public:
    static std::shared_ptr<Product> create() {
        return std::make_shared<T>();
    }
};

int main() {
    auto product_a = Factory<ProductA>::create();
    product_a->do_use();

    auto product_b = Factory<ProductB>::create();
    product_b->do_use();

    return 0;
}

```

运行结果

```sh
product_a created!
product_b created!
```

| 模式     | 特点                 | 使用场景                       |
| -------- | -------------------- | ------------------------------ |
| 简单工厂 | 集中管理对象创建     | 产品种类少、变化不频繁         |
| 工厂方法 | 子类决定创建对象     | 需要扩展新产品时               |
| 抽象工厂 | 创建一系列相关产品   | 多产品族、保证产品兼容性       |
| 模板工厂 | 通过模板生成任意产品 | 高扩展性、减少修改已有工厂代码 |


核心思想:

将对象创建与使用分离, 提高代码可维护性和灵活性

根据复杂度选择不同工厂模式: 简单工厂适合小项目, 抽象工厂适合产品族较多的复杂项目, 模板工厂适合追求高扩展性场景
